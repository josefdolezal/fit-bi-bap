\section{Použité technologie}

V této části se postupně zabývám jednotlivými body analýzy a rozebírám jaké řešení z těch, která jsem analyzoval, jsem zvolil pro implementaci.
Jedním z hlavních kritérií při konečném rozhodování byla slučitelnost jednotlivých částí.
Vzhledem k rozsahu implementace jsem si musel být jistý, že jednotlivé části budou fungovat správně v celé aplikaci.
Rozhodujícím faktorem tedy nebyla popularita jednotlivých řešení ale spíše jejich flexibilita.

\subsection{Architektura aplikace}\label{technologie-architektura}

Nejdůležitějším rozhodnutím bylo správné vybrání architektury.
Špatný výběr architektury by mohl mít dopad na celkovou funkčnost aplikace či znemožnit implementaci některých z vyžadovaných funkcí.

Po podrobném analyzování obou zmíněných architektur jsem se rozhodl využít \acrshort{mvvm}.
Přestože \acrshort{mvvm} není v současné době tak rozšířené, nabízí spoustu vlastností, které standardní \acrshort{mvc} nemá.

Silným argumentem je testování.
V architektuře \acrshort{mvvm} lze jednotlivé části otestovat samostatně.
K otestování logiky aplikace navíc není potřeba vizuální vrstva aplikace.

Neméně podstatným argumentem je čitelnost kódu.
Vrstva \texttt{Controller} obsahuje mnohem méně kódu a lze se v něm snáze orientovat.
ViewModel naopak neobsahuje žádné prvky uživatelského rozhraní a znázorňuje tak pouze způsob, jakým se daná část aplikace chová.
Jednotlivé vrstvy jsou od sebe striktně odděleny a dodržují princip jedné odpovědnosti \cite{toptal-srp}.

\subsubsection*{Implementace ViewModelu}

V části \ref{analyza-mvvm} kde jsem analyzoval architekturu \acrshort{mvvm} jsem naznačil strategii implementace.
ViewModel jsem se rozhodl implementovat jako logiku \texttt{Controlleru}, která jako rozhraní nabízí pouze vstupy či výstupy.

Vstupem označuji uživatelskou interakci, na základě které je potřeba vyžádat nová data nebo zobrazit jinou obrazovku.
Výstupem jsou zobrazovaná data, která jsou ViewModelem předformátovaná aby je \texttt{Controller} mohl přímo zobrazit pomocí View vrstvy.
Jiným výstupem pak může být informace o stavu dat či o jejich počtu (počet položek v seznamu).

Každá obrazovka vlastní svůj ViewModel.
Pro ten jsou dostupné tři protokoly: \textit{ViewModelInputs}, \textit{ViewModelOutputs} a \textit{ViewModelType}.
Tyto prokoly jsou konkrétně pojmenovány podle obrazovky, stejně tak ViewModel samotný a také \texttt{Controller}.
Definice rozhraní je vidět v ukázce \ref{code:viewmodel}.

\swiftcode{code:viewmodel}{Rozhraní objektu ViewModel}{assets/code/viewmodel.swift}

První protokol popisuje množinu vstupů, druhý množinu výstupů a třetí popisuje rozhraní ViewModelu.
Tím jsem dosáhl možnosti zaměňovat ViewModel obrazovky či sdílet jeden ViewModel mezi více obrazovkami.
Návrhem tohoto rozhraní jsem inspiroval v open source aplikaci Kickstarter, dostupné na portálu GitHub \cite{github-kickstarter}.

\subsubsection*{Implementace Controlleru}

\texttt{Controller} při inicializaci vyžaduje instanci ViewModelu.
Veškerou logiku obrazovky pak na ViewModel během svého životního cyklu deleguje.

Uživatelské vstupy jsou implementovány pomocí funkcí.
\texttt{Controller} sleduje uživatelskou interakci a volá patřičné funkce ViewModelu.
Výstupy z ViewModelu jsou pomocí UI bindings napojeny na View v metodě \textit{bindViewModel}, která je volána těsně po načtení View vrstvy do paměti.

\texttt{Controller} vyžaduje v konstruktoru instanci implementující protokol vstupů a výstupů, nikoli konkrétní třídu.

\subsubsection*{Coordinator}

\acrshort{mvvm} standardně nepoužívá objekt spravující navigaci v aplikaci.
Implementoval jsem proto další objekt nazvaný Coordinator.
Jedná se o objekt, který se stará o průběh jedné konkrétní části aplikace (flow).
Jakmile uživatel vyžaduje přechod na obrazovku mimo rozsah stávajícího Coordinatoru, vytvoří se nový Coordinator starající se o novou obrazovku a její životní cyklus.
Coordinator má také na starosti vytvoření ViewModelu a předání jeho instance \texttt{Controlleru}.

Scénář obrazovky se spustí metodou \textit{start}.
Po ukončení (uživatel chce zavřít obrazovku) volá Coordinator metodu \textit{completed} kde se uvolní naalokované zdroje.

S Coordinatorem spolupracuje ViewModel metodou Delegate pattern.

\subsection{Synchronizace vláken}

Pro synchronizaci vláken jsem se rozhodl použít knihovny ReactiveCocoa a ReactiveSwift, tedy reaktivní přístup.
Díky těmto knihovnám lze jednoduše tvořit závislosti asynchronních operací.

S využitím knihovny ReactiveCocoa od verze 5.0 lze navíc využít tkzv. \textit{UI bindings}.
Ty zaručují, že hodnoty signálů jsou vždy zpracovány na hlavním vlákně a to i v momentě, kdy jsou odeslány z vlákna v pozadí.
ReactiveSwift pak zaručuje konzistenci dat mezi vlákny.
Dohromady tak tyto knihovny zamezují vzniku \textit{race condition} za běhu aplikace.
Více o těchto knihovnách lze zjistit z oficiální dokumentace \cite{github-reactiveswift} a \cite{github-reactivecocoa}.

Neméně podstatným faktorem byla i velmi dobrá integrace v architektuře \acrshort{mvvm}.
Pomocí operátorů nad signály lze formátovat vlastnosti modelových objektů (přidání jednotek, standardizace čísel, zástupné texty).
Takto naformátované signály zaručí, že kdykoliv se aktualizuje modelový objekt, jeho vlastnosti budou správně naformátovány.
\texttt{ViewController} tak vždy dostane data ve správném formátu bez ohledu na to, jakým způsobem byly změny na Modelu aplikovány.

\subsection{Síťová vrstva}

Síťovou vrstvu jsem se zpočátku rozhodl implementovat knihovnou Alamofire.
Důvodem byla snazší implementace a integrace do aplikace.
Protože nemá Alamofire striktně danou strukturu koncových bodů, bylo jednoduché implementovat dynamickou URL tiskárny.

Chybějící podpora reaktivního programování ale velmi brzy negativně zasáhla běh aplikace.
K synchronizaci vláken jsem nemohl využít ReactiveSwift a aplikace byla zatížena množstvím chyb vznikajících při vykonávání síťových požadavků a následné serializaci dat.

Z tohoto důvodu jsem se rozhodl využít knihovny Moya, která nabízí reaktivní rozšíření a je kompatibilní s ReactiveSwift.

Veškeré síťové požadavky nakonec využívají knihovnu Moya, s jejíž implementací chyby s vlákny vymizely.

\subsubsection*{Implementace Provider objektu}

Při implementaci jsem se neobešel se standardními objekty, které jsou běžné potřebné.
Provider objekt předimplementovaný v knihovně předpokládá, že adresa vzdáleného serveru je známá již během kompilace a neumožňuje ji zadat za běhu programu.
Z tohoto důvodu jsem také nemohl využít standardní definici koncových bodů pomocí TargetType protokolu, který URL vyžaduje staticky.

Rozhodl jsem vytvořit podtřídu \textit{DynamicProvider}, která v konstruktoru přijme URL serveru.
Místo využití protokolu TargetType jsem vytvořil nový protokol TargetPart, který má stejné rozhraní, jen nevyžaduje URL serveru.

Má implementace Provider objektu využívá tento nový protokol pro vytvoření požadavku.
Abych mohl využít třídu, od které můj objekt DynamicTarget dědí, musel jsem ještě vytvořit strukturu DynamicTarget, která implementuje rozhraní TargetType a využaduje tedy URL serveru.
Tu jí ale může poskytnout v konstruktutoru DynamicProvider spolu s TargetPart koncovým bodem.

Tím jsem dosáhl stejného rozhraní pro požadavky jako má nadtřída, jediným rozdílem je možnost dodat URL až při běhu aplikace.

\subsubsection*{Síťové požadavky mimo OctoPrint}

Pro umožnění zobrazení video streamu jsem opět potřeboval dynamickou URL, ale tentokrát pro každý požadavek (uživatel zadává pouze URL, nejsou žádné koncové body).
Tato implementace nebyla složitá, využil jsem standardních tříd knihovny Moya.
Vytvořil jsem nový objekt spravující koncové body a v něm definoval pouze jeden bod \textit{get}.
Ten pro zkonstruování využaduje koncovou URL a chová se tedy velmi podobně jako kdyby URL byla známá už v čase kompilace.

Při využití je ale nutné pro každý požadavek explicitně URL zadat.
To je krok který v DynamicProvider není nutný.

\subsection{Datová vrstva}

Jak vyplývá z části \ref{analyza-datova-vrstva} kde popisuji datovou vrstvu, rozhodl jsem se využít knihovnu Realm.
Díky jejím reaktivním rozšířením se skvěle hodí nejen k architektuře, ale i k síťové vrstvě.

Při implementaci jsem dospěl k závěru, že standardní cestou využití Realmu opakuji spoustu kódu.
Vytvořil jsem proto rozšíření pro ReactiveCocoa a její Cold signál.

Pro SignalProducer, který jako hodnotu nese Realm objekt jsem přidal dvě metody.
První z nich, \textit{fetch(collectionOf:)} umožňuje z databáze načíst kolekci.
Druhou metodou je \textit{fetch(classType:, forPrimaryKey:)}.
Ta vybere z databáze prvek podle primárního klíče.
Využití metod je vidět v ukázce \ref{code:realm-extensions}.

\swiftcode{code:realm-extensions}{Reaktivní rozšíření pro Realm}{assets/code/realm-extensions.swift}

Díky těmto rozšířením jsem odstranil spoustu duplicitního kódu, navíc jsem sjednotil rozhraní využívaných knihoven.
Mohl jsem díky tomu synchronizovat vlákna síťových volání a datové vrstvy pomocí ReactiveCocoa.

\subsection{Grafické prvky}

Pro ilustrace a ikony v aplikaci jsem se rozhodl využít framework Iconic.
Oproti zmíněnému Assets catalog v mém řešení výkon aplikace nezhoršuje, naopak poskytuje velmi snadným způsobem desítky ikon v jediném fontovém souboru.

Jako grafický font jsem vybral FontAwesome verze 4.7 \cite{fontawesome-web}.
Grafický font jsem využil pro ikony záložek na obrazovce detailu tiskárny ale také pro ikony, které nejsou běžně v systému dostupné.

Protože pomocí grafického fontu není možné vytvořit ikonu aplikaci, využil jsem také Assets catalog.
Využit je ale právě pro ikonu aplikace, ostatní potřebné ilustrace poskytuje Iconic.

Iconic v současné době není podporován správcem závislostí, který jsem si zvolil.
Z tohoto důvodu jsem potřebné soubory pomocí frameworku vygeneroval zvlášť a následně je do projektu vložil.

Současně jsem také nabídl autorovi frameworku pomoc s podporou pro jiné cesty distribuce.
Během implementace této práce se nám ale nepodařilo možnosti distribuce rozšířit.
Více informací o tomto tématu je dostupné na stránce projektu \cite{github-iconic-brew}.

\subsection{Správa závislostí}

Při výběru správce závislostí jsem své nároky směřoval především na ovlivnění kompilace aplikace.
V konečném důsledku pracují oba zanalyzované nástroje podobně, mají ale rozdílný přístup k linkování knihoven.

Přestože nastavení CocoaPods je mnohem snazší, z mého pozorování vyplynulo, že negativně ovlivňuje čas kompilace.
To je způsobeno častou kompilací jednotlivých knihoven a to i v případě, že jejich zdrojový kód nebyl upraven.
Dále jsem vypozoroval, že prostředí Xcode je s CocoaPods méně stabilní, přestává fungovat našeptávání a zvýrazňování syntaxe.

Z těchto důvodů jsem zvolil Carthage.
Počáteční nastavení bylo nepatrně složitější z důvodu ručního integrování knihoven do projektu.
Integrují se ale předem zkompilované knihovny, čas jednotlivých buildů aplikace se tedy nezvyšuje.
Linkování zkompilovaných knihoven má pravděpodobně za následek lepší integraci s Xcode.
Za dobu psaní práce se stalo jen výjimečně, že by se Xcode nečekaně ukončil.
Zlepšilo se také zvýrazňování syntaxe.
To fungovalo během psaní celé práce bez problému.

Výměnou za zlepšené fungování při lokálním vývoji byly problémy při kompilaci na CI serveru.
Nekompatibilita zkompilovaných knihoven s verzí Swift jazyka použitým při vývoji aplikace způsobila, že více než dvě třetiny kompilací na serveru selhalo.
Přehled jednotlivých buildů je vidět na \cite{travis-octophone-builds}.
