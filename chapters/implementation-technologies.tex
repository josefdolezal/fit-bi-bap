\section{Použité technologie}

V této části se postupně zabývám jednotlivými body analýzy a rozebírám jaké řešení z těch, která jsem analyzoval, jsem zvolil pro implementaci.
Jedním z hlavních kritérií při konečném rozhodování byla slučitelnost jednotlivých částí.
Vzhledem k rozsahu implementace jsem si musel být jistý, že jednotlivé části budou fungovat správně v celé aplikaci.
Rozhodujícím faktorem tedy nebyla popularita jednotlivých řešení ale spíše jejich flexibilita.

\subsection{Architektura aplikace}\label{technologie-architektura}

Nejdůležitějším rozhodnutím bylo správné vybrání architektury.
Špatný výběr architektury by mohl mít dopad na celkovou funkčnost aplikace či znemožnit implementaci některých z vyžadovaných funkcí.

Po podrobném analyzování obou zmíněných architektur jsem se rozhodl využít MVVM.
Přestože MVVM není v současné době tak rozšířené, nabízí spoustu vlastností, které standardní MVC nemá.

Silným argumentem je testování.
V architektuře MVVM lze jednotlivé části otestovat samostatně.
K otestování logiky aplikace navíc není potřeba vizuální vrstva aplikace.

Neméně podstatným argumentem je čitelnost kódu.
Vrstva View Controller obsahuje mnohem méně kódu a lze se v něm snáze orientovat.
ViewModel naopak neobsahuje žádné prvky uživatelského rozhraní a znázorňuje tak pouze způsob jakým daná část aplikace chová.
Jednotlivé vrstvy jsou od sebe striktně odděleny a dodržují princip jedné odpovědnosti \cite{toptal-srp}.

\todo{Konkrétní implementace MVVM a Coordinatoru}

\subsection{Synchronizace vláken}

Pro synchronizaci vláken jsem se rozhodl použít knihovny ReactiveCocoa a ReactiveSwift, tedy reaktivní přístup.
Díky těmto knihovnám lze jednoduše tvořit závislosti asynchronních operací.

S využitím knihovny ReactiveCocoa od verze 5.0 lze navíc využít tkzv. \textit{UI bindings}.
Ty zaručují, že hodnoty signálů jsou vždy zpracovány na hlavním vlákně a to i v momentě, kdy jsou odeslány z vlákna v pozadí.
ReactiveSwift pak zaručuje konzistency dat mezi vlákny.
Dohromady tak tyto knihovny zamezují vzniku \textit{race condition} za běhu aplikace.
Více o těchto knihovnách lze zjistit z oficiální dokumentace \cite{github-reactiveswift} a \cite{github-reactivecocoa}.

Neméně podstatným faktorem byla i velmi dobrá integrace v architektuře MVVM.
Pomocí operátorů nad signály lze formátovat vlastnosti modelových objektů (přidání jednotek, standardizace čísel, zástupné texty).
Takto naformátované signály zaručí, že kdykoliv se aktualizuje modelový objekt, jeho vlastnosti budou správně naformátovány.
ViewController tak vždy dostane data ve správném formátu bez ohledu na to, jakým způsobem byly změny na modelu aplikovány.

\subsection{Síťová vrstva}

Síťovou vrstvu jsem se zpočátku rozhodl implementovat knihovnou Alamofire.
Důvodem byla snazší implementace a integrace do aplikace.
Protože nemá Alamofire striktně danou strukturu koncových bodů, bylo jednoduché implementovat dynamickou URL tiskárny.

Chybějící podpora reaktivního programování ale velmi brzy negativně zasáhla běh aplikace.
K synchronizaci vláken jsem nemohl využít ReactiveSwift a aplikace byla zatížena množstvím chyb vznikajících při vykonávání síťových požadavků a následné serializaci dat.

Z tohoto důvodu jsem se rozhodl využít knihovny Moya, která nabízí reaktivní rozšíření a je kompatibilní s ReactiveSwift.

Veškeré síťové požadavky nakonec využívají knihovnu Moya, s jejíž implementací chyby s vlákny vymizely.

\todo{Popis DynamicProvideru a StaticProvideru}

\todo{Realm a reaktivní rozšíření}

\subsection{Grafické prvky}

Pro ilustrace a ikony v aplikaci jsem se rozhodl využít framework Iconic.
Oproti zmíněnému Assets catalog v mém řešení výkon aplikace nezhoršuje, naopak poskytuje velmi snadným způsobem desítky ikon v jediném fontovém souboru.

Jako grafický font jsem vybral FontAwesome verze 4.7 \cite{fontawesome-web}.
Grafický font jsem využil pro ikony záložek na obrazovce detailu tiskárny ale také pro ikony, které nejsou běžně v systému dostupné.

Protože pomocí grafického fontu není možné vytvořit ikonu aplikaci, využil jsem také Assets catalog.
Využit je ale právě pro ikonu aplikace, ostatní potřebné ilustrace poskytuje Iconic.

Iconic v současné době není podporován správcem závislostí, který jsem si zvolil.
Z tohoto důvodu jsem potřebné soubory pomocí frameworku vygeneroval zvlášť a následně je do projektu vložil.

Současně jsem také nabídl autorovi frameworku pomoc s podporou pro jiné cesty distribuce.
Během implementace této práce se nám ale nepodařilo možnosti distribuce rozšířit.
Více informací o tomto tématu je dostupné na stránce projektu \cite{github-iconic-brew}.

\subsection{Správa závislostí}

Při výběru správce závislostí jsem své nároky směřoval především na ovlivnění kompilace aplikace.
V konečném důsledku pracují oba zanalyzované nástroje podobně, mají ale rozdílný přístup k linkování knihoven.

Přestože nastavení CocoaPods je mnohem snazší, z mého pozorování vyplynulo, že negativně ovlivňuje čas kompilace.
To je způsobeno častou kompilací jednotlivých knihoven a to i v případě, že jejich zdrojový kód nebyl upraven.
Dále jsem vypozoroval, že prostředí Xcode je s CocoaPods méně stabilní, přestává fungovat našeptávání a zvýrazňování syntaxe.

Z těchto důvodů jsem zvolil Carthage.
Počáteční nastavení bylo nepatrně složitější z důvodu ručního integrování knihoven do projektu.
Integrují se ale předem zkompilované knihovny, čas jednotlivých buildů aplikace se tedy nezvyšuje.
Linkování zkompilovaných knihoven má pravděpodobně za následek lepší integraci s Xcode.
Za dobu psaní práce se stalo jen výjimečně, že by se Xcode nečekaně ukončil.
Zlepšilo se také zvýrazňování syntaxe.
To fungovalo během psaní celé práce bez problému.

Výměnou za zlepšené fungování při lokálním vývoji byly problémy při kompilaci na CI serveru.
Nekompatibilita zkompilovaných knihoven s verzí Swift jazyka použitým při vývoji aplikace způsobila, že více než dvě třetiny kompilací na serveru selhalo.
Přehled jednotlivých buildů je vidět na \cite{travis-octophone-builds}.
