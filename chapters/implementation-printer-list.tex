\section{Seznam dostupných tiskáren}

Aplikace jsem navrhl tak, aby klíčové funkcionality byly dostupné s co nejkratším průchodem aplikace.
Jako úvodní obrazovku jsem zvolil seznam tiskáren.
V případě, že již uživatel aplikace dříve používal, zobrazí se v seznamu na prvních místech tiskárny, které si uživatel uložil.
Na dalších místech jsou pak tiskárny dostupné na stejné síti, které aplikace automaticky nalezla.

Pokud aplikace požadovanou tiskárnu nenalezla, je ze seznamu tiskáren možné přejít na obrazovku pro manuální přidání tiskárny.

\subsection{Implementace seznamu}

Abych dosáhl uživatelského rozhraní kompatibilního se zařízeními iPhone i iPad, rozhodl jsem se seznam implementovat pomocí CollectionView.
Z analýzy vyplynulo, že velmi podobné seznamy budou dostupné na většině obrazovek.
Rozhodl jsem se tedy zavést novou třídu pokrývající společnou logiku a výchozí nastavení nazvanou BaseCollectionView.

Tato základní třída se stará o barevné sjednocení obrazovek, zobrazování chyb a nastavení View pro prázdné obrazovky.
Jednotlivé obrazovky pak využívají třídy dědící z BaseCollectionView.

\subsubsection*{Sekce seznamu}

Seznam tiskáren je rozdělen na dvě základní sekce.
Pomocí rozdělení do samostatných sekcí jsem dosáhl vytvoření nezávislých řádkových indexů pro každou sekci.
ViewModel pro Controller poskytuje počet řádků pro každou ze sekcí samostatně.
Při vytváření seznamu stačí tedy ověřit pro jakou sekci se záznam v seznamu vytváří a následně ViewModel požádat o data s konkrátním řádkovým indexem číslovaným od nuly.

V případě jedné sekce by bylo nutné vzájmně porovnávat aktuální číslo řádku s počtem uložených tiskáren a tiskáren nalezených.
To požaduje komplexní výpočet a dává prostor mmoha chybám.

\subsubsection*{Uložené tiskárny}

První sekce zobrazuje tiskárny načtené z lokální databáze.
Při sestavování seznamu si pomocí \textit{delegate pattern} CollectionView nejdříve vyžádá počet prvků pro tuto sekci.
Controller tedy využije výstup ViewModelu a vrátí hodnotu jeho proměnné nazvané \textit{storedPrintersCount}.
Implementace této metody je vidět v ukázce \ref{code:printer-list-number-of-rows}.

\swiftcode{code:printer-list-number-of-rows}{Konfigurace počtu tiskáren v seznamu}{assets/code/printer-list-number-of-rows.swift}

V momentě kdy CollectionView ví kolik prvků bude zobrazovat, začne vyžadovat jednotlivé položky seznamu.
K tomu je opět využit delegate pattern.
Pro správné dodržení MVVM architektury nesmí Controller využívat modelové objekty.
Pro každou buňku je tedy potřeba vytvořit ViewModel, který ji bude obsluhovat.
Controller si pro řádkový index vyžádá od svého ViewModelu nový ViewModel buňky a ten jí.
Buňka se následně sama z ViewModelu nakonfiguruje.
Vyžádání ViewModelu buňky zachycuje ukázka \ref{code:printer-list-cell-viewmodel}.

\swiftcode{code:printer-list-cell-viewmodel}{Vytváření buňky v seznamu}{assets/code/printer-list-cell-viewmodel.swift}

\subsubsection*{Síťové tiskárny}

Tato část názorně ukazuje sílu MVVM architektury.
Přesto, že logika stojící za vyhledáním síťových tiskáren není triviální, ViewController zůstává velmi krátký a dobře čitelný.

Z pohledu Controlleru totiž logika není podstatná, důležité jsou výstupy z ní.
ViewModel pro seznam tiskáren jsem proto navrh tak, aby poskytoval obdobné rozhraní jako poskytuje pro uložené tiskárny.

Pro zobrazení druhé sekce seznamu stačí CollectionView předat informaci o počtu síťových tiskáren a buňkám předat odpovídající ViewModely.
Toho se docílí ve stejných metodách jako pro uložnené tiskárny.
Počet síťových tiskáren je uložen v proměnné \textit{networkPrintersCount} a ViewModely je možné získat metodou \textit{networkPrinterCellViewModel}.
