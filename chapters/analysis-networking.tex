\section{Síťování}\label{analyza-sitovani}

Nedílnou součástí aplikace je také síťování, tedy komunikace s rozhraním OctoPrint pomocí REST API.
Síťování je v mém řešení ztěžejní, protože aplikace komunikuje s tiskárnou vždy v reálném čase.
Při analyzování síťové vrstvy jsem dospěl ke třem základním požadavkům:

\begin{enumerate}
    \item Jednotlivé enpointy musí být dobře strukturované.
    \item Implementace musí být generická, aby bylo možné dosáhnout maximální znovupoužitelnosti.
    \item Jednotlivé požadavky musí jít snadno řetězit bez ztráty informací či ignorování chyb.
\end{enumerate}

Mým požadavkům se nejvíce přiblížili tři možná řešení, které následně podrobně popíši.
Řešení jsem analyzoval od těch nejvíce \textit{low-level}, které pracují pouze se standardními knihovnami až po implementace za využití externích knihoven.

\subsection{URLSession}

Jako první možnost pro analýzu jsem vybral základní knihovnu \textit{URLSession}, která je dostupná ve frameworku \textit{Foundation}.
V tuto chvíli se jedná o API, které je nejvíce nízkoúrovňové, i tak ale nabízí vysokou flexibilitu.

Spolu s \textit{URLSession} se pojí i mnoho dalších tříd, které jsou vzájmně závislé.

\subsubsection*{URLSessionConfiguration}

Při vytváření nové instance NSURLSession je potřeba poskytnout konfiguraci.
Tato konfigurace poskytuje základní nastavení pro politiky cachování požadavků, využívané protokoly, nastavení cookies a správu přihlašovacích údajů.
Konfigurace je reprezentována třídou URLSessionConfiguration.

Pro jednoduché aplikace je možné využít předpřipravenou konfiguraci, ta ale přistupuje ke všem požadavkům stejně což je nevhodné pro využití při komunikaci s více vzdálenými body.
Pro svou implementaci bych tedy musel využít dynamické konfigurování v závislosti na aktuálně využívané tiskárně.
V ukázce \ref{code:urlsessionconfiguration} je vidět možná implementace dynamické konfigurace.

\swiftcode{code:urlsessionconfiguration}{Dynamické nastavení URLSession}{assets/code/urlsessionconfiguration.swift}

\subsubsection*{URLSessionTask}

Pro samotnou reprezentaci požadavků se využívají podtřídy abstraktní třídy \textit{URLSessionTask}.
Těmito podtřídami jsou \textit{URLSessionDataTask}, \textit{URLSessionUploadTask} a \textit{URLSessionDownloadTask}.
Ty zprostředkovávají získávání dat (JSON, XML, \ldots) a stahování a nahrávání souborů.
Pro vytvoření těchto tříd nabízí \textit{URLSession} předpřipravené metody.

Samotné vytvoření požadavku pro stažení JSON objektu je vidět v ukázce \ref{code:urlsessionrequest}.

\swiftcode{code:urlsessionrequest}{Vytvoření požadavku pomocí URLSession}{assets/code/urlsessionrequest.swift}

\subsubsection*{Shrnutí}

Přestože \textit{URLSession} nabízí velmi komplexní řešení síťových požadavků byla by implementace velmi náročná.
V současné době nabízí na řetězení požadavků pouze \textit{completion blok}, který ale není pro řetězení mnoha požadavků vhodný (časté opakování kódu, zanořování metod).

Strukturování endpointů v základu také není řešené, bylo by tedy potřeba vytvořit novou abstraktní vrstvu.
Z tohoto důvodu jsem se rozhodl přistoupit ke zanalyzování knihoven třetích stran.

\subsection{Alamofire}

Jako první knihovnu třetích stran jsem se rozhodl zanalyzovat populární Alamofire \cite{github-alamofire}.
Jedná se o síťovací knihovnu, naprogramovanou s využitím \textit{URLSession}.
Alamofire nabízí oproti \textit{URLSession} moderní API využívající sílu jazyka Swift, formátování požadavků (JSON, URL, \ldots) a také validaci odpovědí serveru.

Alamofire navíc nabízí velmi jednoduchý a intuitivní způsob strukturování endpointů pomocí \textit{Routeru}.
Další velkou výhodou je vysoká znovupoužitelnost.
Pomocí vlastních pravidel pro serializování odpovědí serveru je možné vytvořit generické požadavky, jejichž odpovědi nebudou prostý text ale už platný Swift objekt.
Takto serializované objekty lze následně uložit do databáze či používat bez zanesení chyby za běhu aplikace (díky typové kontrole během kompilace).

Pro samotné požadavky využívají \textit{top-level} metody, které sdílí společné nastavení sezení (z anglického \textit{session}).

\subsubsection*{Router}

Pro rozsáhlejší projekty poskytuje Alamofire velmi elegantní způsob strukturování endpointů.
V terminilogii Alamofire se objektu, který endpointy struktuje říká Router.
Zpravidla se jedná výčtový typ (\textit{enum}), kde jednotlivé endpointy jsou reprezentovány pomocí výčtů.

Tyto výčty lze pak předat do Alamofire a tím vytvořit požadavek na server.
Ukázková implementace Router objektu je vidět v ukázce \ref{code:alamofire-router}.

\swiftcode{code:alamofire-router}{Ukázková implementace Router objektu}{assets/code/alamofire-router.swift}

\subsubsection*{SessionManager}

Přestože standardně používané \textit{top-level} metody jsou běžné naprosto dostačující, pro mé řešení jsou nevhodné z důvodu sdílení společného nastavení i pro různé vzdálené body (tiskárny).

Z tohoto důvodu je v Alamofire dostupná třída \textit{SessionManager}, jejíž instance mohou využívat různé nastavení.
\textit{SessionManager} dále nabízí obdobné API jako \textit{top-level} funkce pro vytváření požadavků.

Příklad vytvoření požadavku s nakonfigurovaným \textit{SessionManager} objektem je uveden v ukázce \ref{code:alamofire-sessionmanager}.

\swiftcode{code:alamofire-sessionmanager}{Vytvoření požadavku pomocí Alamofire}{assets/code/alamofire-sessionmanager.swift}

\subsubsection*{Shrnutí}

Alamofire je velmi rozsáhlou knihovnou pro síťové požadavky.
Již v základu obsahuje abstraktní vrstvu nad \textit{URLSession}, kterou bych ve své implementaci musel také napsat.
Pomocí Router objektu lze velmi přehledně a čitelně zapouzdřit jednotlivé endpointy.
Vlastní serializace odpovědí serveru pak umožňuje vysokou znovupoužitelnost bez opakování kódu.

Pro zpracování je nicméně opět dostupný pouze \textit{completion blok}.
Řetězení požadavků zůstává prakticky stejné jako u \textit{URLSession}.

\subsection{Moya}

Jako poslední možné řešení síťových požadavků jsem zvážil open source knihovnu Moya \cite{github-moya}.

Moya je abstraktní vrstva na víše zmíněnou Alamofire.
Nabízí tedy stejné možnosti, klade si ale za cíl uživatele odstínit od správy URL adres a parametrů a dalšího nastavení.

Druhou výhodou je zapouzdřování endpointů do tkzv. \textit{Provider} objektů.
Na rozdíl od Router objektu zapouzdřuje Provider pouze endpointy se stejnými vlastnostmi (např. stejná úroveň řízení přístupu).
Během kompilace tak lze ověřit, že požadavky, které vyžadují oprávnění jsou vytváří stejný Provider.

\medskip

Velmi užitečný je i zcela jiný přístup k vytváření požadavků.
Moya vytváří požadavek ve třech fázích.
Nejprve nechá uživatele vytvořit \textit{Target}, ten se následně mapuje na \textit{Endpoint} z kterého teprve Provider vytvoří samotný požadavek.

\subsubsection*{Target}

Prvním krokem vytváření požadavku je Target.
Target reprezentuje akci, která se má vykonat na vybraném vzdáleném API.
Typicky implementovaný jako enum a poskytuje vysokoúrovňové API pro využití ve zbytku aplikace.
Implementace targetu je vidět v ukázce \ref{code:moya-target}.

\swiftcode{code:moya-target}{Moya - Implementace Target objektu}{assets/code/moya-target.swift}

\subsubsection*{Endpoint}

Endpoint je interní struktura reprezentující koncový bod, která je využita k sestavení požadavku.
Hlavním cílem této struktury je možnost modifikovat způsob, jakým budou požadavky vytvořeny.
Pomocí Endpoint objektu lze např. přidávat autorizační token či některé požadavky rušit, opozdit atp.

\subsubsection*{Provider}

Při použití Moyi se veškeré požadavky odesílají skrz Provider.
Provider je generický objekt, který operuje na objektem Target.
Tím se v době kompilace dosáhne kontroly kompatibility Provider s Target objektem.

Provider nabízí rozhraní pro modifikaci vytvoření Endpointu i pro modifikaci požadavku.
Vytvoření požadavku je vidět v ukázce \ref{code:moya-provider}.

\swiftcode{code:moya-provider}{Moya - vytvoření požadavku}{assets/code/moya-provider.swift}

\subsubsection*{Reaktivní rozšíření}

Moya v základu nabízí rozšíření pro použití s reaktivními knihovnami.
Díky tomu lze velmi dobře integrovat s architekturou MVVM, konkrétně do vrstvy View Model.
Usnadňuje tím také možnost řetězení požadavků pomocí flatMap operátoru jak je vidět v ukázce \ref{code:moya-reactive-extensions}.

\swiftcode{code:moya-reactive-extensions}{Moya - Řetězení požadavků}{assets/code/moya-reactive-extensions.swift}

\subsubsection*{Testování}

Jednou z největších výhod Moyi je možnost testování.
V Target objektu je možné definovat, jaká data má požadavek vrátit v době kdy se aplikace testuje.
Tím Moya zaručí, že testy nebudou selhávat v případě kdy nebude dostupná síť.

Pro případ testování chování aplikace v momentě kdy je síť nedostupná nebo kdy požadavky selžou je možné opět využít úpravy Endpoint objektu.

\subsubsection*{Shrnutí}

Moya je knihovna pro vytvoření abstrakce nad síťovou vrstvou.
Tato nová vrstva se stává jediným spojením aplikace s internetem.

Obsahuje totožné funkce jako knihovna Alamofire, kterou ve své implementaci využívá.
Oproti Alamofire navíc nabízí striktní oddělení Endpoint a Terget objektů.

Tím umožňuje požadavky automaticky mockovat při testování.

Díky reaktivním rozšířením lze navíc velmi dobře integrovat s architekturou MVVM.